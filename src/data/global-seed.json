{
  "global_tool_flows": [
    {
      "tool_name": "taskpilot_start",
      "flow_steps": [
        {
          "step_order": 1,
          "system_tool_fn": "taskpilot_start",
          "feedback_step": null,
          "next_tool": "end"
        }
      ]
    },
    {
      "tool_name": "taskpilot_init",
      "flow_steps": [
        {
          "step_order": 1,
          "system_tool_fn": "taskpilot_init",
          "feedback_step": null,
          "next_tool": "end"
        }
      ]
    },
    {
      "tool_name": "taskpilot_add",
      "flow_steps": [
        {
          "step_order": 1,
          "system_tool_fn": "taskpilot_add",
          "feedback_step": "analytical_validation",
          "next_tool": "taskpilot_create_task"
        }
      ]
    },
    {
      "tool_name": "taskpilot_create_task",
      "flow_steps": [
        {
          "step_order": 1,
          "system_tool_fn": "taskpilot_create_task",
          "feedback_step": null,
          "next_tool": "end"
        }
      ]
    },
    {
      "tool_name": "taskpilot_status",
      "flow_steps": [
        {
          "step_order": 1,
          "system_tool_fn": "taskpilot_status",
          "feedback_step": "status_analysis",
          "next_tool": "end"
        }
      ]
    },
    {
      "tool_name": "taskpilot_update",
      "flow_steps": [
        {
          "step_order": 1,
          "system_tool_fn": "taskpilot_update",
          "feedback_step": null,
          "next_tool": "end"
        }
      ]
    },
    {
      "tool_name": "taskpilot_focus",
      "flow_steps": [
        {
          "step_order": 1,
          "system_tool_fn": "taskpilot_focus",
          "feedback_step": null,
          "next_tool": "end"
        }
      ]
    },
    {
      "tool_name": "taskpilot_audit",
      "flow_steps": [
        {
          "step_order": 1,
          "system_tool_fn": "taskpilot_audit",
          "feedback_step": "audit_analysis",
          "next_tool": "end"
        }
      ]
    },
    {
      "tool_name": "taskpilot_github",
      "flow_steps": [
        {
          "step_order": 1,
          "system_tool_fn": "taskpilot_github",
          "feedback_step": "github_validation",
          "next_tool": "taskpilot_update"
        }
      ]
    },
    {
      "tool_name": "taskpilot_rule_update",
      "flow_steps": [
        {
          "step_order": 1,
          "system_tool_fn": "taskpilot_rule_update",
          "feedback_step": null,
          "next_tool": "end"
        }
      ]
    }
  ],
  "global_feedback_steps": [
    {
      "name": "analytical_validation",
      "instructions": "Apply the 6-step analytical thinking framework:\n\n1. **Logical Consistency**: Evaluate statements for internal coherence and contradictions\n2. **Evidence Quality**: Assess the strength and reliability of supporting data/reasoning\n3. **Hidden Assumptions**: Identify unstated premises that may affect outcomes\n4. **Cognitive Biases**: Detect emotional reasoning, confirmation bias, or wishful thinking\n5. **Causal Relationships**: Verify claimed cause-and-effect relationships are valid\n6. **Alternative Perspectives**: Consider competing explanations or approaches\n\nIf validation passes, proceed to call the next tool. If validation fails, provide constructive feedback with specific suggestions for improvement.",
      "metadata": {
        "category": "validation",
        "timeout_minutes": 5,
        "required_for": ["task_creation", "requirement_analysis"]
      }
    },
    {
      "name": "post_task_validation",
      "instructions": "After task completion, ensure quality standards:\n\n1. Run all relevant unit tests for modified code\n2. Check code formatting and linting compliance\n3. Verify task progress is accurately recorded (0-100%)\n4. Update connected file list with all modified files\n5. Create git commit with task ID reference\n6. Move completed task to done file\n\nOnly mark task as 100% complete when ALL checks pass. If any checks fail, provide specific remediation steps.",
      "metadata": {
        "category": "completion",
        "timeout_minutes": 10,
        "required_for": ["task_completion", "quality_assurance"]
      }
    },
    {
      "name": "status_analysis",
      "instructions": "Provide comprehensive project status analysis:\n\n1. Summarize tasks by status (Backlog, In-Progress, Blocked, Review, Done)\n2. Identify rule violations and compliance issues\n3. Highlight overdue or blocked tasks with reasons\n4. Calculate progress metrics and velocity trends\n5. Suggest priority adjustments based on dependencies\n6. Recommend next actions for project advancement\n\nPresent findings in a clear, actionable format with specific recommendations.",
      "metadata": {
        "category": "analysis",
        "timeout_minutes": 3,
        "required_for": ["project_oversight", "progress_tracking"]
      }
    },
    {
      "name": "audit_analysis",
      "instructions": "Perform thorough project audit:\n\n1. Review all task completion verification\n2. Identify orphaned dependencies and broken links\n3. Check for inconsistent task status updates\n4. Verify connected file lists are accurate\n5. Validate git commit references match tasks\n6. Suggest cleanup actions for project health\n\nProvide detailed findings with priority-ranked remediation steps.",
      "metadata": {
        "category": "audit",
        "timeout_minutes": 8,
        "required_for": ["project_health", "quality_assurance"]
      }
    },
    {
      "name": "github_validation",
      "instructions": "Validate GitHub integration and synchronization:\n\n1. Verify repository connection and credentials\n2. Check bidirectional sync between tasks and issues\n3. Validate webhook configurations and event handling\n4. Ensure task status updates reflect GitHub changes\n5. Confirm issue creation from tasks is working\n6. Review any sync conflicts or missing data\n\nRecommend corrective actions for any integration issues found.",
      "metadata": {
        "category": "integration",
        "timeout_minutes": 5,
        "required_for": ["github_sync", "external_integration"]
      }
    },
    {
      "name": "code_review",
      "instructions": "Conduct comprehensive code review:\n\n1. Check adherence to coding standards and style guides\n2. Verify proper error handling and edge case coverage\n3. Assess code maintainability and readability\n4. Validate security best practices implementation\n5. Ensure adequate test coverage and quality\n6. Review performance implications and optimizations\n\nProvide specific, actionable feedback for code improvements.",
      "metadata": {
        "category": "quality",
        "timeout_minutes": 15,
        "required_for": ["code_quality", "peer_review"]
      }
    },
    {
      "name": "testing_requirements",
      "instructions": "Validate testing requirements and coverage:\n\n1. Ensure unit tests exist for all new functionality\n2. Verify integration tests cover critical workflows\n3. Check test coverage meets minimum thresholds (80%)\n4. Validate test quality and edge case coverage\n5. Confirm end-to-end tests for user-facing features\n6. Review test performance and execution time\n\nRecommend additional testing where gaps are identified.",
      "metadata": {
        "category": "testing",
        "timeout_minutes": 10,
        "required_for": ["quality_assurance", "continuous_integration"]
      }
    }
  ]
}